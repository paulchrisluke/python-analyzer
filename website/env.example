# Cloudflare D1 HTTP Driver Configuration for Local Development
CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
CLOUDFLARE_D1_DATABASE_ID=your-d1-database-id
CLOUDFLARE_API_TOKEN=your-cloudflare-api-token

# CORS Configuration
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001

# Admin Configuration (server-only). Do NOT expose secrets/PII via NEXT_PUBLIC_*.
# Comma-separated list of admin email addresses (placeholders):
ADMIN_EMAILS="admin@cranberryhearing.com,paul@cranberryhearing.com,paulchrisluke@gmail.com"
# Store only password hashes via your secret manager (e.g., Vercel/Cloudflare secrets).
# Do not commit real values.
# SECURITY: Never leave this empty in production. Always set explicit password hashes.
# For development, use a documented dev-only override with DEV_AUTH_ROLE flag.
# Generate hashes using: bcrypt with cost factor 12 (recommended for production)
# Example: ADMIN_PASSWORD_HASHES="$2b$12$N9qo8uLOickgx2ZMRZoMye,$2b$12$N9qo8uLOickgx2ZMRZoMye"
# Note: Server uses bcrypt cost factor 12. Generate compatible hashes using: bcrypt.hash(password, 12)
# CRITICAL: These are bcrypt hashes, NOT plaintext passwords. Users provide plaintext passwords
# which are verified against these hashes using bcrypt.compare()

# Buyer Configuration (server-only). Do NOT expose secrets/PII via NEXT_PUBLIC_*.
# Comma-separated list of buyer email addresses (placeholders):
BUYER_EMAILS="buyer@example.com,investor@example.com"
# Store only password hashes via your secret manager (e.g., Vercel/Cloudflare secrets).
# Do not commit real values.
# SECURITY: Never leave this empty in production. Always set explicit password hashes.
# For development, use a documented dev-only override with DEV_AUTH_ROLE flag.
# Generate hashes using: bcrypt with cost factor 12 (recommended for production)
# Example: BUYER_PASSWORD_HASHES="$2b$12$N9qo8uLOickgx2ZMRZoMye,$2b$12$N9qo8uLOickgx2ZMRZoMye"
# Note: Server uses bcrypt cost factor 12. Generate compatible hashes using: bcrypt.hash(password, 12)
# CRITICAL: These are bcrypt hashes, NOT plaintext passwords. Users provide plaintext passwords
# which are verified against these hashes using bcrypt.compare()

# NextAuth.js Secret for session token signing (server-only, never exposed to client)
# Generate a strong secret using: openssl rand -base64 64
# Rotate immediately if compromised. Store via your secret manager in all environments.
# Never prefix with NEXT_PUBLIC_ or expose to client-side code.
NEXTAUTH_SECRET=your-super-secret-jwt-key-here-minimum-32-characters
NEXTAUTH_URL=http://localhost:3000

# Test Configuration
TEST_USER_EMAIL=testuser@example.com
TEST_USER_PASSWORD=testpass123!
TEST_ADMIN_EMAIL=admin@example.com
TEST_ADMIN_PASSWORD=admin123!
TEST_BUYER_EMAIL=buyer@example.com
TEST_BUYER_PASSWORD=buyer123!

# Application URLs
# Base URL for the Next.js application
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Environment
NODE_ENV=development

# Development Authentication (OPT-IN)
# Set to a role name to bypass authentication in development mode only
# Valid values: 'admin', 'buyer' (or leave unset for normal authentication)
# WARNING: Only use this for local development - never set in production
# To enable locally, uncomment and set one of the following:
# DEV_AUTH_ROLE=admin    # Test as admin user
# DEV_AUTH_ROLE=buyer    # Test as buyer user
# Leave unset (default) to use normal authentication
DEV_AUTH_ROLE=

# Data Directory Configuration
# Directory path for admin dashboard data files (server-side only)
# Used by CI/CD to specify alternative data location (e.g., .data for admin files)
# MUST be a non-public/server-only directory to prevent exposing sensitive data
# Defaults to '.data' if not set
# ADMIN_DATA_DIR=.data

# SECURITY WARNING: Client-side Authorization Anti-Pattern
# DO NOT use NEXT_PUBLIC_* variables for authorization or email allowlists
# This exposes PII and enables client-side enumeration attacks
# 
# Instead, use server-side authentication with:
# 1. JWT session tokens with role claims (recommended)
# 2. Server-side /me endpoint for role validation
# 3. Middleware-based route protection
#
# Example server-side role gating:
# - Check JWT token claims in middleware
# - Validate user roles against server-only ADMIN_EMAILS/BUYER_EMAILS
# - Never expose email lists or authorization logic to client
#
# FAIL CLOSED: Never rely on client-side values for authorization
# These values can be manipulated and should NEVER be used in production
